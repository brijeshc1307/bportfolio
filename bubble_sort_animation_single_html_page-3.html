<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sorting Visualizer — Multi‑Algorithm (11 sorts)</title>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee;
      --compare:#f97316; --swap:#ef4444; --sorted:#22c55e; --bar:#60a5fa; --outline:#334155;
      --warn:#fde047; --info:#38bdf8;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:radial-gradient(1200px 600px at 70% -10%,#1e293b 0%,var(--bg) 60%);color:var(--text)}
    header{padding:24px 16px 8px;text-align:center}
    h1{margin:0;font-size:clamp(22px,3vw,32px);letter-spacing:.3px}
    .sub{color:var(--muted);font-size:14px;margin-top:6px}
    .wrap{max-width:1200px;margin:0 auto;padding:12px 16px 28px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid rgba(148,163,184,.12);border-radius:18px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:center}
    .control{background:var(--panel);border:1px solid rgba(148,163,184,.15);color:var(--text);padding:10px 12px;border-radius:12px;display:flex;align-items:center;gap:10px}
    .control label{font-size:12px;color:var(--muted)}
    .control input[type="range"], .control input[type="text"]{width:200px}
    .control input[type="text"]{padding:8px 10px;border-radius:10px;border:1px solid var(--outline);background:#0b1220;color:var(--text)}
    .algos{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
    .chip{display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid rgba(148,163,184,.2);border-radius:999px;background:#0b1220;cursor:pointer}
    .chip input{accent-color:#22d3ee}
    .btn{cursor:pointer;border:none;border-radius:12px;padding:10px 14px;font-weight:600;background:linear-gradient(90deg,var(--accent),#3b82f6);color:#002230;letter-spacing:.2px;transition:transform .08s ease,filter .2s ease}
    .btn:hover{filter:brightness(1.05)} .btn:active{transform:scale(.98)}
    .btn.secondary{background:#1f2937;color:var(--text);border:1px solid rgba(148,163,184,.18)}
    .btn.ghost{background:transparent;border:1px dashed rgba(148,163,184,.3);color:var(--muted)}
    .stage{height:320px;position:relative;margin-top:12px;background:rgba(2,6,23,.35);border:1px solid rgba(148,163,184,.12);border-radius:18px;padding:10px;overflow:hidden}
    .bars{position:absolute;inset:10px;display:flex;align-items:flex-end;gap:4px;width:calc(100% - 20px)}
    .bar{flex:1 1 auto;background:linear-gradient(180deg,rgba(255,255,255,.25),rgba(255,255,255,.05)),var(--bar);border-radius:8px 8px 4px 4px;height:10px;transition:height .2s ease,background .12s ease,transform .2s ease;position:relative;display:flex;align-items:flex-start;justify-content:center}
    .bar span{position:absolute;top:-18px;font-size:10px;color:var(--text)}
    .bar.compare{background:var(--compare)} .bar.swap{background:var(--swap)} .bar.sorted{background:var(--sorted)}
    .legend{display:flex;gap:14px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:8px;color:var(--muted);font-size:12px}
    .key{display:flex;gap:6px;align-items:center} .dot{width:12px;height:12px;border-radius:50%}
    .dot.bar{background:var(--bar)} .dot.compare{background:var(--compare)} .dot.swap{background:var(--swap)} .dot.sorted{background:var(--sorted)}
    .metrics{display:flex;gap:12px;justify-content:center;margin-top:8px;font-variant-numeric:tabular-nums;flex-wrap:wrap}
    .metric{background:rgba(148,163,184,.08);border:1px solid rgba(148,163,184,.15);padding:6px 10px;border-radius:10px}
    .algopanel{margin-top:18px}
    .algopanel h3{margin:0 0 6px 0;font-size:16px;color:#cbd5e1;display:flex;align-items:center;gap:8px}
    .row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;align-items:center;margin-top:10px}
    .notice{color:var(--warn);font-size:12px;text-align:center;margin-top:6px}
    .summary{margin-top:18px}
    table{width:100%;border-collapse:collapse;border:1px solid rgba(148,163,184,.2);}
    th,td{padding:8px;border-top:1px solid rgba(148,163,184,.15);text-align:center;font-size:13px}
    th{background:#0b1220;color:#cbd5e1}
  </style>
</head>
<body>
  <header>
    <h1>Sorting Visualizer — Multi‑Algorithm</h1>
    <div class="sub">Pick algorithms, enter your integer array (negatives allowed), and compare animations vertically.</div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="controls">
        <div class="control" style="flex:1 1 320px;max-width:650px">
          <label>Custom Array (integers, comma‑separated)</label>
          <input id="arrayInput" type="text" placeholder="e.g. -12, 5, -3, 8, 0, 20" />
        </div>
        <div class="control">
          <label>Array Length</label>
          <input id="size" type="range" min="5" max="50" value="20" />
          <span id="sizeVal">20</span>
        </div>
        <div class="control">
          <label>Speed</label>
          <input id="speed" type="range" min="1" max="100" value="70" />
          <span id="speedVal">70</span>
        </div>
        <div class="control">
          <label>Distribution</label>
          <select id="dist">
            <option value="random">Random</option>
            <option value="nearly">Nearly Sorted</option>
            <option value="rev">Reverse</option>
            <option value="few">Few Unique</option>
          </select>
        </div>
      </div>

      <div class="algos" id="algoChips"></div>

      <div class="row">
        <button id="gen" class="btn secondary" title="Use random or preset distribution">Generate Array</button>
        <button id="useInput" class="btn" title="Use the custom array from input">Use Custom Array</button>
        <button id="startAll" class="btn" title="Start all panels">Start All</button>
        <button id="pauseAll" class="btn ghost" title="Pause all panels">Pause All</button>
        <button id="resetAll" class="btn ghost" title="Reset all panels">Reset All</button>
      </div>
      <div class="notice" id="notice"></div>
    </div>

    <div id="panels"></div>

    <div class="panel summary" id="summaryPanel" style="display:none">
      <h3 style="margin:0 0 8px 0">Run Summary</h3>
      <table id="summaryTable">
        <thead><tr><th>Algorithm</th><th>Comparisons</th><th>Swaps/Writes</th><th>Passes/Phases</th><th>Elapsed (ms)</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const sleep = ms => new Promise(r=>setTimeout(r, ms));
    const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));

    function mapSpeedToDelay(){
      const s = +$('#speed').value; // 1..100 (higher=faster)
      return 8 + Math.floor(900 * Math.pow(1 - s/100, 2));
    }

    function parseIntArray(text){
      if(!text) return null;
      const nums = text.split(',').map(x=>x.trim()).filter(x=>x.length>0).map(x=>{
        if(/^[-+]?\d+$/.test(x)) return parseInt(x,10);
        return NaN;
      }).filter(n=>Number.isInteger(n));
      return nums.length? nums : null;
    }

    function rand(min,max){return Math.floor(Math.random()*(max-min+1))+min;}
    function genArray(n,mode){
      const vals=[];
      if(mode==='random') for(let i=0;i<n;i++) vals.push(rand(-99,99));
      else if(mode==='rev') for(let i=n;i>=1;i--) vals.push(-100 + Math.floor(i/n*200));
      else if(mode==='nearly'){
        for(let i=1;i<=n;i++) vals.push(-100 + Math.floor(i/n*200));
        for(let k=0;k<Math.max(3,Math.floor(n*0.05));k++){ const a=rand(0,n-1), b=rand(0,n-1); [vals[a],vals[b]]=[vals[b],vals[a]]; }
      } else if(mode==='few'){
        const choices=[-50,-25,0,25,50,75]; for(let i=0;i<n;i++) vals.push(choices[rand(0,choices.length-1)]);
      }
      return vals;
    }

    // ---------- Visualization ----------
    function createBars(container, values){
      container.innerHTML='';
      const minV = Math.min(...values), maxV = Math.max(...values);
      const span = maxV - minV || 1;
      const scale = v => ((v - minV) / span) * 260 + 20; // 20..280 px
      return values.map(v=>{
        const el = document.createElement('div');
        el.className='bar';
        el.style.height = scale(v)+'px';
        const label = document.createElement('span');
        label.textContent = v;
        el.appendChild(label);
        container.appendChild(el);
        return el;
      });
    }

    function updateBar(el, value, minV, maxV){
      const span = (maxV - minV) || 1; const h = ((value - minV)/span)*260 + 20;
      el.style.height = h+'px';
      el.querySelector('span').textContent = value;
    }

    function clearHL(a,b,bars){ if(bars[a]) bars[a].classList.remove('compare','swap'); if(bars[b]) bars[b].classList.remove('compare','swap'); }

    // ---------- Algorithm Generators (yield step objects) ----------
    // Each yield: {type:'compare'|'swap'|'set'|'mark'|'phase', i, j, value, index, range}

    function *bubbleSort(arr){
      let n = arr.length; let comps=0, swaps=0, pass=1; let swapped;
      for(let i=0;i<n-1;i++){
        swapped=false;
        for(let j=0;j<n-1-i;j++){
          yield {type:'compare', i:j, j:j+1, comps:++comps, swaps, pass};
          if(arr[j] > arr[j+1]){
            [arr[j],arr[j+1]] = [arr[j+1],arr[j]]; swaps++;
            yield {type:'swap', i:j, j:j+1, comps, swaps, pass};
            swapped=true;
          }
        }
        yield {type:'mark', index:n-1-i, pass:++pass, comps, swaps};
        if(!swapped) break;
      }
      for(let k=0;k<n;k++) yield {type:'mark', index:k};
    }

    function *selectionSort(arr){
      let n=arr.length, comps=0, swaps=0;
      for(let i=0;i<n-1;i++){
        let min=i;
        for(let j=i+1;j<n;j++){
          yield {type:'compare', i:min, j, comps:++comps, swaps, pass:i+1};
          if(arr[j]<arr[min]) min=j;
        }
        if(min!==i){ [arr[i],arr[min]]=[arr[min],arr[i]]; swaps++; yield {type:'swap', i, j:min, comps, swaps, pass:i+1}; }
        yield {type:'mark', index:i};
      }
      yield {type:'mark', index:n-1};
    }

    function *insertionSort(arr){
      let comps=0, swaps=0;
      for(let i=1;i<arr.length;i++){
        let key=arr[i]; let j=i-1; yield {type:'phase', label:`Insert @${i}`};
        while(j>=0 && (comps++, arr[j]>key)){
          yield {type:'compare', i:j, j:j+1, comps, swaps, pass:i};
          arr[j+1]=arr[j]; swaps++; yield {type:'set', index:j+1, value:arr[j], comps, swaps, pass:i};
          j--;
        }
        arr[j+1]=key; yield {type:'set', index:j+1, value:key, comps, swaps, pass:i};
      }
      for(let k=0;k<arr.length;k++) yield {type:'mark', index:k};
    }

    function *mergeSort(arr){
      // Iterative bottom-up merge sort for easier stepping
      let n=arr.length; let comps=0, writes=0;
      for(let size=1; size<n; size*=2){
        for(let left=0; left<n; left+=2*size){
          let mid=Math.min(left+size, n), right=Math.min(left+2*size, n);
          let i=left, j=mid; const tmp=[];
          while(i<mid && j<right){
            yield {type:'compare', i, j, comps:++comps, swaps:writes, pass:size};
            if(arr[i]<=arr[j]) tmp.push(arr[i++]); else tmp.push(arr[j++]);
          }
          while(i<mid) tmp.push(arr[i++]);
          while(j<right) tmp.push(arr[j++]);
          for(let k=0;k<tmp.length;k++){ arr[left+k]=tmp[k]; writes++; yield {type:'set', index:left+k, value:tmp[k], comps, swaps:writes, pass:size}; }
        }
      }
      for(let k=0;k<n;k++) yield {type:'mark', index:k};
    }

    function *quickSort(arr){
      // Lomuto partition iterative
      let stack=[[0,arr.length-1]]; let comps=0, swaps=0;
      while(stack.length){
        const [lo,hi]=stack.pop(); if(lo>=hi) continue;
        let i=lo; for(let j=lo;j<hi;j++){
          yield {type:'compare', i:j, j:hi, comps:++comps, swaps};
          if(arr[j] <= arr[hi]){ [arr[i],arr[j]]=[arr[j],arr[i]]; swaps++; yield {type:'swap', i, j, comps, swaps}; i++; }
        }
        [arr[i],arr[hi]]=[arr[hi],arr[i]]; swaps++; yield {type:'swap', i, j:hi, comps, swaps};
        stack.push([lo,i-1],[i+1,hi]);
      }
      for(let k=0;k<arr.length;k++) yield {type:'mark', index:k};
    }

    function *heapSort(arr){
      let n=arr.length, comps=0, swaps=0;
      function *siftDown(i,limit){
        while(true){
          let l=2*i+1, r=2*i+2, largest=i;
          if(l<limit){ yield {type:'compare', i:l, j:largest, comps:++comps, swaps}; if(arr[l]>arr[largest]) largest=l; }
          if(r<limit){ yield {type:'compare', i:r, j:largest, comps:++comps, swaps}; if(arr[r]>arr[largest]) largest=r; }
          if(largest!==i){ [arr[i],arr[largest]]=[arr[largest],arr[i]]; swaps++; yield {type:'swap', i, j:largest, comps, swaps}; i=largest; }
          else break;
        }
      }
      // build heap
      for(let i=Math.floor(n/2)-1;i>=0;i--) yield* siftDown(i,n);
      for(let end=n-1; end>0; end--){ [arr[0],arr[end]]=[arr[end],arr[0]]; swaps++; yield {type:'swap', i:0, j:end, comps, swaps}; yield* siftDown(0,end); yield {type:'mark', index:end}; }
      yield {type:'mark', index:0};
    }

    function *countingSort(arr){
      // Works with negatives via offset
      const minV = Math.min(...arr), maxV=Math.max(...arr); const offset = -minV; const range = maxV - minV + 1;
      const count = new Array(range).fill(0); let writes=0;
      for(let v of arr){ count[v+offset]++; yield {type:'phase', label:`Count ${v}`}; }
      for(let i=1;i<count.length;i++) count[i]+=count[i-1];
      const out = new Array(arr.length);
      for(let i=arr.length-1;i>=0;i--){ const v=arr[i]; out[--count[v+offset]] = v; yield {type:'phase', label:`Place ${v}`}; }
      for(let i=0;i<arr.length;i++){ arr[i]=out[i]; writes++; yield {type:'set', index:i, value:out[i], swaps:writes}; }
      for(let k=0;k<arr.length;k++) yield {type:'mark', index:k};
    }

    function *radixSort(arr){
      // LSD Radix for integers with negatives: separate negatives/positives
      const neg = arr.filter(v=>v<0).map(v=>-v);
      const pos = arr.filter(v=>v>=0);
      function *radixNonNeg(a){
        let max = a.reduce((m,v)=>Math.max(m,Math.abs(v)),0); let exp=1; let writes=0;
        const base=10;
        while(Math.floor(max/exp)>0){
          const out = new Array(a.length).fill(0); const cnt = new Array(base).fill(0);
          for(let v of a){ cnt[Math.floor(Math.abs(v)/exp)%base]++; }
          for(let i=1;i<base;i++) cnt[i]+=cnt[i-1];
          for(let i=a.length-1;i>=0;i--){ const v=a[i]; out[--cnt[Math.floor(Math.abs(v)/exp)%base]] = v; }
          for(let i=0;i<a.length;i++){ a[i]=out[i]; writes++; yield {type:'phase', label:`digit ${exp}`}; }
          exp*=10;
        }
      }
      yield* radixNonNeg(neg);
      yield* radixNonNeg(pos);
      // rebuild: negatives reversed (because of absolute sorting) then positives
      const rebuilt = neg.reverse().map(v=>-v).concat(pos);
      for(let i=0;i<arr.length;i++){ arr[i]=rebuilt[i]; yield {type:'set', index:i, value:arr[i]}; }
      for(let k=0;k<arr.length;k++) yield {type:'mark', index:k};
    }

    function *bucketSort(arr){
      // Simple bucket sort into 10 buckets across range, then insertion per bucket
      const minV=Math.min(...arr), maxV=Math.max(...arr); const nBuckets=10;
      const span = (maxV-minV)||1; const buckets = Array.from({length:nBuckets},()=>[]);
      for(let v of arr){ const idx = Math.min(nBuckets-1, Math.floor((v-minV)/span*nBuckets)); buckets[idx].push(v); yield {type:'phase', label:`Bucket ${idx}`}; }
      function insertion(a){ for(let i=1;i<a.length;i++){ let k=a[i], j=i-1; while(j>=0 && a[j]>k){ a[j+1]=a[j]; j--; } a[j+1]=k; } }
      let k=0; for(let b=0;b<nBuckets;b++){ insertion(buckets[b]); for(let v of buckets[b]){ arr[k]=v; yield {type:'set', index:k, value:v}; k++; } }
      for(let i=0;i<arr.length;i++) yield {type:'mark', index:i};
    }

    function *shellSort(arr){
      let n=arr.length, comps=0, swaps=0;
      for(let gap=Math.floor(n/2); gap>0; gap=Math.floor(gap/2)){
        for(let i=gap;i<n;i++){
          let temp=arr[i], j=i; yield {type:'phase', label:`gap ${gap}`};
          while(j>=gap && (comps++, arr[j-gap]>temp)){
            yield {type:'compare', i:j-gap, j, comps:comps, swaps:swaps};
            arr[j]=arr[j-gap]; swaps++; yield {type:'set', index:j, value:arr[j-gap], comps, swaps}; j-=gap;
          }
          arr[j]=temp; yield {type:'set', index:j, value:temp, comps, swaps};
        }
      }
      for(let i=0;i<n;i++) yield {type:'mark', index:i};
    }

    function *timSort(arr){
      // Simplified TimSort: identify natural runs + insertion sort per run + merge like merge sort
      const n=arr.length; const RUN=32; let comps=0, writes=0;
      function insertion(a,l,r){ for(let i=l+1;i<=r;i++){ let key=a[i], j=i-1; while(j>=l && a[j]>key){ a[j+1]=a[j]; j--; } a[j+1]=key; } }
      for(let i=0;i<n;i+=RUN){ insertion(arr, i, Math.min(i+RUN-1, n-1)); for(let k=i;k<Math.min(i+RUN,n);k++) yield {type:'set', index:k, value:arr[k]}; }
      for(let size=RUN; size<n; size*=2){
        for(let left=0; left<n; left+=2*size){
          const mid=Math.min(left+size, n), right=Math.min(left+2*size, n);
          let i=left, j=mid; const tmp=[];
          while(i<mid && j<right){ yield {type:'compare', i, j, comps:++comps, swaps:writes}; if(arr[i]<=arr[j]) tmp.push(arr[i++]); else tmp.push(arr[j++]); }
          while(i<mid) tmp.push(arr[i++]); while(j<right) tmp.push(arr[j++]);
          for(let k=0;k<tmp.length;k++){ arr[left+k]=tmp[k]; writes++; yield {type:'set', index:left+k, value:tmp[k], comps, swaps:writes}; }
        }
      }
      for(let i=0;i<n;i++) yield {type:'mark', index:i};
    }

    const ALGORITHMS = [
      ['Bubble Sort', bubbleSort],
      ['Selection Sort', selectionSort],
      ['Insertion Sort', insertionSort],
      ['Merge Sort', mergeSort],
      ['Quick Sort', quickSort],
      ['Heap Sort', heapSort],
      ['Counting Sort', countingSort],
      ['Radix Sort', radixSort],
      ['Bucket Sort', bucketSort],
      ['Shell Sort', shellSort],
      ['Tim Sort', timSort],
    ];

    // ---------- Panels / Runners ----------
    class Runner{
      constructor(name, algo, baseArray){
        this.name=name; this.algo=algo; this.base=baseArray.slice(); this.arr=this.base.slice();
        this.running=false; this.done=false; this.comps=0; this.swaps=0; this.pass=1; this.startTime=0; this.elapsed=0;
        this.root=document.createElement('div'); this.root.className='panel algopanel';
        this.root.innerHTML=`
          <h3>🧮 ${name}
            <span style="font-size:11px;color:var(--muted);font-weight:400">(independent controls)</span>
          </h3>
          <div class="stage"><div class="bars" aria-label="array bars"></div></div>
          <div class="legend">
            <div class="key"><span class="dot bar"></span>Default</div>
            <div class="key"><span class="dot compare"></span>Comparing</div>
            <div class="key"><span class="dot swap"></span>Swapping/Writing</div>
            <div class="key"><span class="dot sorted"></span>Sorted</div>
          </div>
          <div class="metrics">
            <div class="metric">Comparisons: <span class="m-cmp">0</span></div>
            <div class="metric">Swaps/Writes: <span class="m-swp">0</span></div>
            <div class="metric">Pass/Phase: <span class="m-pass">1</span></div>
            <div class="metric">Elapsed: <span class="m-time">0</span> ms</div>
          </div>
          <div class="row">
            <button class="btn start">Start</button>
            <button class="btn ghost step">Step</button>
            <button class="btn secondary pause">Pause</button>
            <button class="btn ghost reset">Reset</button>
          </div>
        `;
        this.barsEl=this.root.querySelector('.bars');
        this.cmpEl=this.root.querySelector('.m-cmp');
        this.swpEl=this.root.querySelector('.m-swp');
        this.passEl=this.root.querySelector('.m-pass');
        this.timeEl=this.root.querySelector('.m-time');
        this.startBtn=this.root.querySelector('.start');
        this.pauseBtn=this.root.querySelector('.pause');
        this.resetBtn=this.root.querySelector('.reset');
        this.stepBtn=this.root.querySelector('.step');
        this.bars=createBars(this.barsEl,this.arr);
        this.gen=this.algo(this.arr);
        this.bind();
      }
      bind(){
        this.startBtn.addEventListener('click',()=>this.run());
        this.pauseBtn.addEventListener('click',()=>this.pause());
        this.resetBtn.addEventListener('click',()=>this.reset());
        this.stepBtn.addEventListener('click',()=>{ if(!this.running) this.step(); });
      }
      updateMetrics(extra={}){
        if('comps' in extra) this.comps=extra.comps;
        if('swaps' in extra) this.swaps=extra.swaps;
        if('pass' in extra) this.pass=extra.pass;
        this.cmpEl.textContent=this.comps; this.swpEl.textContent=this.swaps; this.passEl.textContent=this.pass;
      }
      async step(){
        if(this.done) return false;
        const {value:step,done} = this.gen.next();
        if(done){ this.finish(); return false; }
        await this.applyStep(step); return true;
      }
      async applyStep(step){
        const delay = mapSpeedToDelay();
        const {type}=step;
        if(type==='compare'){
          const {i,j}=step; this.updateMetrics(step);
          this.bars[i]?.classList.add('compare'); this.bars[j]?.classList.add('compare');
          await sleep(delay);
          this.bars[i]?.classList.remove('compare'); this.bars[j]?.classList.remove('compare');
        } else if(type==='swap'){
          const {i,j}=step; this.updateMetrics(step);
          this.bars[i]?.classList.add('swap'); this.bars[j]?.classList.add('swap');
          await sleep(delay);
          const minV=Math.min(...this.arr), maxV=Math.max(...this.arr);
          updateBar(this.bars[i], this.arr[i], minV, maxV);
          updateBar(this.bars[j], this.arr[j], minV, maxV);
          this.bars[i]?.classList.remove('swap'); this.bars[j]?.classList.remove('swap');
        } else if(type==='set'){
          const {index,value}=step; this.updateMetrics(step);
          const minV=Math.min(...this.arr), maxV=Math.max(...this.arr);
          updateBar(this.bars[index], value, minV, maxV);
          await sleep(delay);
        } else if(type==='mark'){
          const {index}=step; this.bars[index]?.classList.add('sorted');
        } else if(type==='phase'){
          this.pass = (this.pass||0)+1; this.updateMetrics({pass:this.pass}); await sleep(delay/2);
        }
      }
      async run(){ if(this.running) return; this.running=true; if(!this.startTime) this.startTime=performance.now();
        while(this.running && !this.done){ const more = await this.step(); if(!more) break; }
      }
      pause(){ this.running=false; if(this.startTime) this.elapsed += performance.now()-this.startTime; this.startTime=0; this.timeEl.textContent=Math.floor(this.elapsed); }
      reset(){ this.running=false; this.done=false; this.arr=this.base.slice(); this.bars=createBars(this.barsEl,this.arr); this.gen=this.algo(this.arr); this.comps=0; this.swaps=0; this.pass=1; this.elapsed=0; this.startTime=0; this.updateMetrics({comps:0,swaps:0,pass:1}); this.timeEl.textContent='0'; }
      finish(){ this.done=true; this.running=false; if(this.startTime){ this.elapsed += performance.now()-this.startTime; this.startTime=0;} this.timeEl.textContent=Math.floor(this.elapsed); this.arr.forEach((_,i)=>this.bars[i]?.classList.add('sorted')); onRunnerFinished(this); }
    }

    // ---------- App State ----------
    const chipsEl = $('#algoChips');
    const panelsEl = $('#panels');
    const summaryPanel = $('#summaryPanel');
    const summaryBody = $('#summaryTable tbody');
    const notice = $('#notice');

    let baseArray = genArray(+$('#size').value, $('#dist').value);
    let runners = [];

    function renderAlgoChips(){
      chipsEl.innerHTML='';
      ALGORITHMS.forEach(([name])=>{
        const id = name.replace(/\s+/g,'-').toLowerCase();
        const chip = document.createElement('label'); chip.className='chip';
        chip.innerHTML = `<input type="checkbox" value="${name}" /> ${name}`;
        chipsEl.appendChild(chip);
      });
    }

    function selectedAlgorithms(){
      return $$('#algoChips input:checked').map(i=>i.value);
    }

    function buildPanels(){
      panelsEl.innerHTML=''; runners = [];
      const algos = selectedAlgorithms();
      if(algos.length===0){ notice.textContent='Select at least one algorithm to visualize.'; return; } else notice.textContent='';
      algos.forEach(name=>{
        const algo = ALGORITHMS.find(([n])=>n===name)[1];
        const r = new Runner(name, algo, baseArray);
        panelsEl.appendChild(r.root); runners.push(r);
      });
      summaryPanel.style.display='none'; summaryBody.innerHTML='';
    }

    function updateBaseArrayFromInput(){
      const txt = $('#arrayInput').value;
      const parsed = parseIntArray(txt);
      if(parsed && parsed.length>0){
        if(parsed.length>200) { notice.textContent='Max 200 elements allowed; truncating for performance.'; baseArray = parsed.slice(0,200); }
        else { notice.textContent='Using custom array.'; baseArray = parsed.slice(); }
        // cap render width by resizing bars via flex; additionally runners will re-render on reset/build
      } else { notice.textContent='No valid integers found in input.'; }
    }

    function setSize(n){ $('#sizeVal').textContent=n; baseArray = genArray(n, $('#dist').value); buildPanels(); }

    // Finish tracking
    let finishedCount = 0;
    function onRunnerFinished(r){
      finishedCount++;
      const row = document.createElement('tr');
      row.innerHTML = `<td>${r.name}</td><td>${r.comps}</td><td>${r.swaps}</td><td>${r.pass}</td><td>${Math.floor(r.elapsed)}</td>`;
      summaryBody.appendChild(row);
      if(finishedCount === runners.length){ summaryPanel.style.display='block'; finishedCount=0; }
    }

    // ---------- Events ----------
    renderAlgoChips();
    buildPanels();

    $('#size').addEventListener('input', e=> $('#sizeVal').textContent=e.target.value);
    $('#size').addEventListener('change', e=> setSize(+e.target.value));
    $('#speed').addEventListener('input', e=> $('#speedVal').textContent=e.target.value);
    $('#dist').addEventListener('change', ()=> setSize(+$('#size').value));

    chipsEl.addEventListener('change', buildPanels);

    $('#gen').addEventListener('click', ()=>{ baseArray = genArray(+$('#size').value, $('#dist').value); buildPanels(); });
    $('#useInput').addEventListener('click', ()=>{ updateBaseArrayFromInput(); buildPanels(); });

    $('#startAll').addEventListener('click', ()=> runners.forEach(r=>r.run()));
    $('#pauseAll').addEventListener('click', ()=> runners.forEach(r=>r.pause()));
    $('#resetAll').addEventListener('click', ()=> runners.forEach(r=>r.reset()));

    // Default select a few algos for convenience
    $$('#algoChips input').slice(0,3).forEach(i=>{ i.checked=true; });
    buildPanels();
  </script>
</body>
</html>
